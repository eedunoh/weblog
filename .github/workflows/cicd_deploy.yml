
# Comments are added for better explanation
name: CI/CD Pipeline For GitHub Actions


# Stage 1: Trigger
on:
  push:                     # Every push to main triggers the workflow
    branches:
      - main

  workflow_dispatch:        # Defined to allow manual runs with inputs (needed for terraform destroy)
    inputs:
      destroy:
        description: "Destroy infrastructure?"
        required: true
        default: "false"


# Stage 2: Define the Jobs
jobs:
  deploy:
    runs-on: ubuntu-latest


    # Stage 3: Secrets and environment variable
    env:
      IMAGE_NAME: jackedu/weblog_repo
      IMAGE_TAG: latest
      TERRAFORM_DIR: terraform_folder
      TF_PLAN_FILE: tfplan.binary
    

    steps:
      # Stage 4: Checkout your code. 
      # When GitHub Actions runs your workflow, it launches a fresh virtual machine (runner). That VM is empty — it does not automatically contain your repository code.
      # So similar to Jenkins, if you want to: Run Terraform (terraform init, terraform plan, etc.) or Build Docker images (needs your Dockerfile), you need the repo files available inside the runner. 
      # That’s what this step does:
      - name: Checkout repository
        uses: actions/checkout@v3
      


      # Stage 5: Build Docker Image
      - name: Build Docker Image

      # This condition is necessary because right now, Docker build, push and terraform plan/apply are in the same job with terraform destroy. 
      # That means on manual runs with destroy=true, it will still run the pre-destroy steps like docker-push and terraform-apply before running terraform destroy, and that is not ideal.
        if: github.event.inputs.destroy != 'true'
        run: |
          cd app_folder
          docker build -t $IMAGE_NAME:$IMAGE_TAG .
      


      # Stage 6: Login to DockerHub
      - name: Login to DockerHub
        if: github.event.inputs.destroy != 'true'
        uses: docker/login-action@v2    
        #This is a reusable package (like plugins or modules) that someone has written and published on the GitHub Marketplace. 
        #docker/login-action@v2 → An action by Docker Inc. that logs in to Docker Hub (or any registry). It uses your stored secrets (DOCKER_USERNAME, DOCKER_PASSWORD) to authenticate before you push/pull images.
        
        with: 
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}



      # Stage 7: Push Image to DockerHub
      - name: Push Image to DockerHub
        if: github.event.inputs.destroy != 'true'
        run: |
          docker push $IMAGE_NAME:$IMAGE_TAG
      


      # Stage 8: Initialize Terraform
      - name: Initialize Terraform
        uses: hashicorp/setup-terraform@v2    
        #This is a reusable package (like plugins or modules) that someone has written and published on the GitHub Marketplace. 
        # hashicorp/setup-terraform@v2 → An action by HashiCorp that installs Terraform in the GitHub Actions runner. Without it, the runner has no Terraform installed.
        
        with:
          terraform_version: 1.6.0
        #This is an input to the action. It tells setup-terraform which Terraform version to install on the runner.


      # Stage 9: Configure Terraform
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-north-1


      # Stage 10: Terraform Init And Plan 
      - name: Terraform Init And Plan
        run: |
            cd $TERRAFORM_DIR
            terraform init
            terraform plan -out=$TF_PLAN_FILE


      # Stage 11: Terraform Apply 

      # Every time you git push to main, the workflow is triggered. It checks out your repo, sets up Terraform, and authenticates to AWS. Runs terraform init, plan, and then automatically applies infra. 
      # No manual click needed. Deployment is continuous.

      - name: Terraform Apply

      # Manual trigger with destroy=true → Skips Apply → Destroys infra.
        if: github.event.inputs.destroy != 'true'
        run: |
          cd $TERRAFORM_DIR
          terraform apply -auto-approve $TF_PLAN_FILE
    

      # Stage 12: Destroy Infra
      - name: Terraform Destroy

      # It only runs the step if a workflow input variable named destroy equals "true". That input comes from workflow_dispatch, which lets you trigger workflows manually and pass parameters.
      # When you trigger this workflow manually in GitHub’s Actions tab, you’ll see a dropdown/input asking: Destroy infrastructure? 
      # If you pick "true" → the step with if: github.event.inputs.destroy == 'true' runs.
      # If "false" → that step is skipped.

        if: github.event.inputs.destroy == 'true'
        run: |
          cd $TERRAFORM_DIR
          terraform destroy -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      


# Something to note:
# if: github.event_name == 'workflow_dispatch' →  Checks the type of trigger. It runs if the workflow was triggered manually, regardless of what inputs were passed.

# if: github.event.inputs.destroy == 'true' →  Checks the value of an input variable from the manual trigger. Runs only if you ran the workflow manually AND selected destroy = true.


# So:
# First one checks how the workflow was started.
# Second one checks what options were passed when it started.